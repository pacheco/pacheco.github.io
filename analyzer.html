<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>APC Effectiveness Analyzer</title>

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">

    <!-- D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <style>
        body {
            background-color: #f8f9fa;
        }

        .drop-zone {
            border: 3px dashed #dee2e6;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background-color: white;
        }

        .drop-zone:hover,
        .drop-zone.dragover {
            border-color: #0d6efd;
            background-color: #e7f1ff;
        }

        .chart-container {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }

        .bar-highlight {
            stroke: #ffc10755 !important;
            stroke-width: 2 !important;
        }
        
        .bar-selected {
            stroke: #ffc107 !important;
            stroke-width: 4 !important;
        }

        .code-panel-container {
            position: relative;
        }

        .sticky-label-header {
            position: sticky;
            top: 0;
            z-index: 100;
            background-color: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 8px 10px;
            font-weight: bold;
            color: #1565c0;
            font-family: 'Courier New', monospace;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .sticky-label-header.active {
            display: block;
        }

        .sticky-label-header:hover {
            background-color: #bbdefb;
        }

        .code-panel {
            font-family: 'Courier New', monospace;
            background-color: #f8f9fa;
            border-radius: 5px;
            padding: 15px;
            max-height: 500px;
            overflow-y: auto;
            position: relative;
        }

        .label-line {
            background-color: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 8px 10px;
            margin: 15px 0 5px 0;
            font-weight: bold;
            color: #1565c0;
        }

        .label-name {
            font-size: 11px;
            word-break: break-all;
            line-height: 1.4;
        }

        .labels-table {
            width: 100%;
            margin-top: 10px;
            font-size: 12px;
        }

        .labels-table th {
            cursor: pointer;
            user-select: none;
            padding: 8px;
            background-color: #f8f9fa;
            border-bottom: 2px solid #dee2e6;
            position: relative;
        }

        .labels-table th:hover {
            background-color: #e9ecef;
        }

        .labels-table th.sorted-asc::after {
            content: ' ▲';
            font-size: 10px;
        }

        .labels-table th.sorted-desc::after {
            content: ' ▼';
            font-size: 10px;
        }

        .labels-table td {
            padding: 8px;
            border-bottom: 1px solid #dee2e6;
        }

        .labels-table tbody tr {
            cursor: pointer;
        }

        .labels-table tbody tr:hover {
            background-color: #f8f9fa;
        }

        .label-cell {
            max-width: 400px;
            word-break: break-all;
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }

        .collapsible-header {
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .collapsible-header:hover {
            opacity: 0.8;
        }

        .collapse-icon {
            transition: transform 0.3s;
            font-size: 14px;
        }

        .collapse-icon.collapsed {
            transform: rotate(-90deg);
        }

        .labels-table-wrapper {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #dee2e6;
            border-radius: 5px;
        }

        .label-row {
            position: relative;
        }

        .expand-icon {
            display: inline-block;
            width: 16px;
            transition: transform 0.2s;
            cursor: pointer;
        }

        .expand-icon.expanded {
            transform: rotate(90deg);
        }

        .blocks-detail-row {
            background-color: #f8f9fa;
        }

        .blocks-detail-row td:nth-child(2) {
            padding-left: 30px !important;
        }

        .blocks-detail-row:hover {
            background-color: #e9ecef;
        }

        .code-block {
            border: 1px solid #dee2e6;
            border-radius: 3px;
            margin: 10px 0;
            padding: 10px;
            background-color: white;
        }

        .code-block-header {
            font-weight: bold;
            margin-bottom: 5px;
            color: #495057;
            font-size: 12px;
        }

        .code-block.selected {
            border-color: #ffc107;
            background-color: #fff9e6;
            box-shadow: 0 0 5px rgba(255, 193, 7, 0.3);
        }

        .code-line {
            margin: 2px 0;
            padding: 2px 5px;
            cursor: pointer;
        }

        .code-line:hover {
            background-color: #e9ecef;
        }

        .code-line.highlighted {
            background-color: #fff3cd;
        }

        .tooltip {
            position: absolute;
            text-align: left;
            padding: 10px;
            font: 12px sans-serif;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            border-radius: 5px;
            pointer-events: none;
            z-index: 1000;
        }

        .bar {
            stroke: black;
            stroke-width: 0.5;
            opacity: 0.8;
            cursor: pointer;
        }

        .bar:hover {
            opacity: 1;
        }

        .mean-line {
            stroke: red;
            stroke-width: 2;
            stroke-dasharray: 5, 5;
            opacity: 0.7;
        }

        .grid line {
            stroke: #e0e0e0;
            stroke-opacity: 0.7;
        }

        .grid path {
            stroke-width: 0;
        }
    </style>
</head>

<body>
    <nav class="navbar navbar-dark bg-primary">
        <div class="container-fluid">
            <span class="navbar-brand mb-0 h1" id="pageTitle" style="cursor: pointer;">APC Effectiveness Analyzer</span>
        </div>
    </nav>

    <div class="container mt-4">
        <!-- File Upload Section -->
        <div id="uploadSection" class="row mb-4">
            <div class="col-12">
                <div class="drop-zone" id="dropZone">
                    <h4>Drop JSON file here or click to upload</h4>
                    <p class="text-muted">Upload APC candidates JSON file</p>
                    <input type="file" id="fileInput" accept=".json" style="display: none;">
                </div>
                <div class="mt-3">
                    <div class="input-group">
                        <span class="input-group-text">Or paste URL:</span>
                        <input type="text" id="urlInput" class="form-control" placeholder="https://example.com/data.json or GitHub link">
                        <button class="btn btn-primary" id="loadUrlBtn">Load from URL</button>
                    </div>
                    <small class="text-muted">Supports direct JSON URLs and GitHub file links</small>
                </div>
            </div>
        </div>

        <!-- Controls Section (hidden initially) -->
        <div id="controlsSection" class="row mb-4" style="display: none;">
            <div class="col-12">
                <div class="row align-items-end">
                    <div class="col-md-3">
                        <label for="effectivenessType" class="form-label">Effectiveness Metric:</label>
                        <select id="effectivenessType" class="form-select">
                            <option value="cost" selected>Cost</option>
                            <option value="main_columns">Main Columns</option>
                            <option value="constraints">Constraints</option>
                            <option value="bus_interactions">Bus Interactions</option>
                        </select>
                    </div>
                    <div class="col-md-3 ms-auto">
                        <label for="pcSearch" class="form-label">Block ID:</label>
                        <div class="input-group">
                            <input type="text" id="pcSearch" class="form-control">
                            <button class="btn btn-primary" id="pcSearchBtn">Go</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Visualization Section (hidden initially) -->
        <div id="vizSection" style="display: none;">
            <!-- Trace Cells Summary -->
            <div class="row mb-3">
                <div class="col-12">
                    <div class="chart-container">
                        <div class="row text-center">
                            <div class="col-md-4">
                                <div class="p-2">
                                    <div class="text-muted small">Original Trace Cells</div>
                                    <div id="originalTraceCells" class="fs-4 fw-bold text-secondary">-</div>
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="p-2">
                                    <div class="text-muted small">Optimized Trace Cells</div>
                                    <div id="optimizedTraceCells" class="fs-4 fw-bold text-primary">-</div>
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="p-2">
                                    <div class="text-muted small">Saved Trace Cells</div>
                                    <div id="savedTraceCells" class="fs-4 fw-bold text-success">-</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="row">
                <div class="col-12">
                    <div class="chart-container">
                        <div id="chart"></div>
                    </div>
                </div>
            </div>

            <!-- Labels Summary Section -->
            <div class="row mt-4" id="labelsSummarySection" style="display: none;">
                <div class="col-12">
                    <div class="chart-container">
                        <div class="collapsible-header" id="labelsHeader">
                            <span class="collapse-icon collapsed">▼</span>
                            <h5 style="margin: 0;">Labels</h5>
                        </div>
                        <div id="labelsContent" style="display: none; margin-top: 10px;">
                            <div class="labels-table-wrapper">
                                <div id="labelsTableContainer"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Code Panel Section -->
            <div class="row mt-4">
                <div class="col-12">
                    <div class="chart-container">
                        <h5>Program Code</h5>
                        <div class="mb-2">
                            <span id="codeBlockInfo" class="text-muted">Click on a bar or code line to select a block</span>
                        </div>
                        <div class="code-panel-container">
                            <div id="stickyLabelHeader" class="sticky-label-header"></div>
                            <div id="codePanel" class="code-panel">
                                <span class="text-muted">No data loaded</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let currentData = null;
        let currentLabels = {};
        let chart = null;
        let selectedBlock = null;

        // File handling
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const uploadSection = document.getElementById('uploadSection');
        const controlsSection = document.getElementById('controlsSection');
        const vizSection = document.getElementById('vizSection');
        const effectivenessType = document.getElementById('effectivenessType');
        const pageTitle = document.getElementById('pageTitle');
        const pcSearch = document.getElementById('pcSearch');
        const pcSearchBtn = document.getElementById('pcSearchBtn');

        // Drop zone events
        dropZone.addEventListener('click', () => fileInput.click());

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        // URL loading functionality
        const urlInput = document.getElementById('urlInput');
        const loadUrlBtn = document.getElementById('loadUrlBtn');

        loadUrlBtn.addEventListener('click', loadFromUrl);
        urlInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                loadFromUrl();
            }
        });

        async function loadFromUrl() {
            const url = urlInput.value.trim();
            if (!url) {
                alert('Please enter a URL');
                return;
            }

            // Convert GitHub URLs to raw URLs
            let fetchUrl = url;
            if (url.includes('github.com') && !url.includes('raw.githubusercontent.com')) {
                // Convert github.com/user/repo/blob/branch/file to raw.githubusercontent.com/user/repo/branch/file
                fetchUrl = url.replace('github.com', 'raw.githubusercontent.com').replace('/blob/', '/');
            }

            try {
                loadUrlBtn.disabled = true;
                loadUrlBtn.textContent = 'Loading...';
                
                const response = await fetch(fetchUrl);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const text = await response.text();
                try {
                    const jsonData = JSON.parse(text);
                    loadData(jsonData);
                    uploadSection.style.display = 'none';
                    controlsSection.style.display = 'block';
                    vizSection.style.display = 'block';
                    updateVisualization();

                    // Update URL to include the data parameter
                    const newUrl = new URL(window.location);
                    newUrl.searchParams.set('data', url);
                    window.history.replaceState({}, document.title, newUrl);
                } catch (parseError) {
                    alert('Error parsing JSON from URL: ' + parseError.message);
                }
            } catch (error) {
                alert('Error loading URL: ' + error.message);
            } finally {
                loadUrlBtn.disabled = false;
                loadUrlBtn.textContent = 'Load from URL';
            }
        }

        effectivenessType.addEventListener('change', () => {
            if (currentData) {
                const selectedBlockId = selectedBlock ? selectedBlock.block_id : null;
                updateVisualization();

                // Restore selection if it exists
                if (selectedBlockId) {
                    const data = processData();
                    const block = data.find(d => d.block_id === selectedBlockId);
                    if (block) {
                        selectBlock(block);
                    }
                }
            }
        });

        // PC search functionality
        pcSearchBtn.addEventListener('click', searchForPC);
        pcSearch.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                searchForPC();
            }
        });

        function searchForPC() {
            if (!currentData) {
                alert('Please load data first');
                return;
            }

            const input = pcSearch.value.trim();
            if (!input) {
                // Empty input means unselect
                selectBlock(null);
                hideSearchResults();
                return;
            }

            // Parse hex (0x...) or decimal
            let pcValue;
            if (input.toLowerCase().startsWith('0x')) {
                pcValue = parseInt(input, 16);
            } else {
                pcValue = parseInt(input, 10);
            }

            if (isNaN(pcValue)) {
                alert('Invalid PC address. Please enter a valid hex (0x...) or decimal number.');
                return;
            }

            // Find all blocks that contain this PC
            // Each instruction is 4 bytes, so PC advances by 4
            const data = processData();
            const matches = data.filter(d => {
                if (d.is_other) return false; // Skip "Other" grouped blocks
                // Check all sub-blocks within this APC
                return d.blocks.some(subBlock => {
                    const startPc = subBlock.start_pc;
                    const endPc = startPc + (subBlock.statements.length * 4);
                    return pcValue >= startPc && pcValue < endPc;
                });
            });

            if (matches.length === 0) {
                alert(`No block found containing PC: 0x${pcValue.toString(16)} (${pcValue})`);
                hideSearchResults();
            } else if (matches.length === 1) {
                selectBlock(matches[0]);
                hideSearchResults();
            } else {
                // Multiple matches - show selection dropdown
                showSearchResults(matches, pcValue);
            }
        }

        function showSearchResults(matches, pcValue) {
            let resultsDiv = document.getElementById('searchResults');
            if (!resultsDiv) {
                resultsDiv = document.createElement('div');
                resultsDiv.id = 'searchResults';
                resultsDiv.style.cssText = 'position: absolute; background: white; border: 1px solid #dee2e6; border-radius: 5px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); max-height: 300px; overflow-y: auto; z-index: 1000; width: 100%;';
                pcSearch.parentElement.style.position = 'relative';
                pcSearch.parentElement.appendChild(resultsDiv);
            }

            resultsDiv.innerHTML = `
                <div style="padding: 8px; background: #f8f9fa; border-bottom: 1px solid #dee2e6; font-weight: bold;">
                    ${matches.length} blocks contain PC 0x${pcValue.toString(16)}
                </div>
                ${matches.map(block => {
                    const pcs = block.blocks.map(b => '0x' + b.start_pc.toString(16)).join(' → ');
                    return `
                        <div class="search-result-item" data-block-id="${block.block_id}"
                             style="padding: 8px 12px; cursor: pointer; border-bottom: 1px solid #eee; font-family: monospace; font-size: 12px;">
                            <div><strong>${pcs}</strong></div>
                            <div style="color: #666; font-size: 11px;">
                                ${block.blocks.length} sub-blocks, ${block.instructions} instructions, effectiveness: ${block.effectiveness.toFixed(2)}
                            </div>
                        </div>
                    `;
                }).join('')}
            `;
            resultsDiv.style.display = 'block';

            // Add click handlers
            resultsDiv.querySelectorAll('.search-result-item').forEach(item => {
                item.addEventListener('click', function() {
                    const blockId = this.getAttribute('data-block-id');
                    const data = processData();
                    const block = data.find(d => d.block_id === blockId);
                    if (block) {
                        selectBlock(block);
                    }
                    hideSearchResults();
                });
                item.addEventListener('mouseenter', function() {
                    this.style.backgroundColor = '#e9ecef';
                });
                item.addEventListener('mouseleave', function() {
                    this.style.backgroundColor = '';
                });
            });
        }

        function hideSearchResults() {
            const resultsDiv = document.getElementById('searchResults');
            if (resultsDiv) {
                resultsDiv.style.display = 'none';
            }
        }

        // Hide search results when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('#pcSearch') && !e.target.closest('#searchResults') && !e.target.closest('#pcSearchBtn')) {
                hideSearchResults();
            }
        });
        
        pageTitle.addEventListener('click', () => {
            currentData = null;
            currentLabels = {};
            selectedBlock = null;
            uploadSection.style.display = 'block';
            controlsSection.style.display = 'none';
            vizSection.style.display = 'none';
            fileInput.value = '';
            urlInput.value = '';
            // Clear URL parameters when returning to upload screen
            window.history.replaceState({}, document.title, window.location.pathname);
        });

        // Check for URL parameter on page load
        window.addEventListener('DOMContentLoaded', () => {
            const urlParams = new URLSearchParams(window.location.search);
            const dataUrl = urlParams.get('url') || urlParams.get('data');
            
            if (dataUrl) {
                urlInput.value = dataUrl;
                loadFromUrl();
            }
        });

        function handleFile(file) {
            if (!file.name.endsWith('.json')) {
                alert('Please upload a JSON file');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const jsonData = JSON.parse(e.target.result);
                    loadData(jsonData);
                    uploadSection.style.display = 'none';
                    controlsSection.style.display = 'block';
                    vizSection.style.display = 'block';
                    updateVisualization();
                } catch (error) {
                    alert('Error parsing JSON file: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        function loadData(jsonData) {
            // Backwards compatible: check if it's the new format with "apcs" and "labels" keys
            if (jsonData && typeof jsonData === 'object' && !Array.isArray(jsonData) &&
                'apcs' in jsonData && 'labels' in jsonData) {
                // New format
                currentData = jsonData.apcs;
                currentLabels = jsonData.labels;
            } else {
                // Old format - assume it's the array of APCs directly
                currentData = jsonData;
                currentLabels = {};
            }
        }

        function calculateEffectiveness(item, effType) {
            switch (effType) {
                case 'cost':
                    return item.cost_before / item.cost_after;
                case 'main_columns':
                    return item.stats.before.main_columns / item.stats.after.main_columns;
                case 'constraints':
                    return item.stats.before.constraints / item.stats.after.constraints;
                case 'bus_interactions':
                    return item.stats.before.bus_interactions / item.stats.after.bus_interactions;
                default:
                    throw new Error(`Unknown effectiveness type: ${effType}`);
            }
        }

        function formatCellCount(count) {
            if (count >= 1e9) {
                return (count / 1e9).toFixed(1) + 'B';
            } else if (count >= 1e6) {
                return (count / 1e6).toFixed(1) + 'M';
            } else if (count >= 1e3) {
                return (count / 1e3).toFixed(1) + 'K';
            } else {
                return count.toFixed(0);
            }
        }

        function getBlockId(blocks) {
            // Create a unique ID from the sequence of start_pcs
            return blocks.map(b => b.start_pc).join('-');
        }

        function processData() {
            const effType = effectivenessType.value;
            const processed = currentData.map(item => {
                const blocks = item.original_block.blocks;
                // Concatenate all statements from contained blocks
                const allStatements = blocks.flatMap(b => b.statements);
                // Use sequence of start_pcs as the block identifier
                const blockId = getBlockId(blocks);
                // First start_pc for display purposes
                const firstPc = blocks[0].start_pc;

                return {
                    block_id: blockId,
                    start_pc: firstPc,  // Keep for backwards compatibility
                    blocks: blocks,  // Keep the sub-blocks for code display
                    effectiveness: calculateEffectiveness(item, effType),
                    instructions: allStatements.length,
                    software_version_cells: item.width_before * item.execution_frequency,
                    width_before: item.width_before,
                    execution_frequency: item.execution_frequency,
                    statements: allStatements,  // Concatenated code statements
                    stats_after: item.stats.after  // Keep APC stats
                };
            });

            // Sort by software_version_cells descending
            processed.sort((a, b) => b.software_version_cells - a.software_version_cells);

            return processed;
        }

        function updateVisualization() {
            const data = processData();
            const totalCells = data.reduce((sum, d) => sum + d.software_version_cells, 0);

            // Calculate trace cells summary
            const originalTraceCells = currentData.reduce((sum, item) => sum + item.execution_frequency * item.cost_before, 0);
            const optimizedTraceCells = currentData.reduce((sum, item) => sum + item.execution_frequency * item.cost_after, 0);
            const savedTraceCells = originalTraceCells - optimizedTraceCells;

            // Update trace cells display
            document.getElementById('originalTraceCells').textContent = formatCellCount(originalTraceCells);
            document.getElementById('optimizedTraceCells').textContent = formatCellCount(optimizedTraceCells);
            document.getElementById('savedTraceCells').textContent = formatCellCount(savedTraceCells) + ` (${((savedTraceCells / originalTraceCells) * 100).toFixed(1)}%)`;

            // Calculate weighted mean
            const meanEffectiveness = data.reduce((sum, d) => sum + d.effectiveness * d.software_version_cells, 0) / totalCells;

            // Create visualization
            createChart(data, totalCells, meanEffectiveness);

            // Show all code in the code panel
            showAllCode();

            // Create labels summary table if there are labels
            createLabelsSummary();

            // Check for block parameter in URL and select it
            const urlParams = new URLSearchParams(window.location.search);
            const blockParam = urlParams.get('block');
            if (blockParam) {
                // block_id is a sequence of PCs joined by '-'
                const block = data.find(d => d.block_id === blockParam);
                if (block) {
                    selectBlock(block);
                }
            }
        }

        function aggregateLabelData() {
            const effType = effectivenessType.value;
            const labelStats = {};

            // Sort blocks by first PC to process them in order
            const sortedBlocks = [...currentData].sort((a, b) =>
                a.original_block.blocks[0].start_pc - b.original_block.blocks[0].start_pc
            );

            // Track current active label(s)
            let currentActiveLabels = [];

            // Iterate through all blocks in PC order
            sortedBlocks.forEach(item => {
                const firstPc = item.original_block.blocks[0].start_pc;
                const pcKey = firstPc.toString();

                // Check if this block starts a new label
                if (currentLabels[pcKey] && currentLabels[pcKey].length > 0) {
                    currentActiveLabels = currentLabels[pcKey];

                    // Initialize label stats if needed
                    currentActiveLabels.forEach(label => {
                        if (!labelStats[label]) {
                            labelStats[label] = {
                                label: label,
                                pc: firstPc,
                                blocks: [],
                                totalTraceCells: 0,
                                totalCostBefore: 0,
                                totalCostAfter: 0
                            };
                        }
                    });
                }

                // Assign this block to all current active labels
                currentActiveLabels.forEach(label => {
                    labelStats[label].blocks.push(item);

                    // Add trace cells (same as x-axis in chart)
                    labelStats[label].totalTraceCells += item.width_before * item.execution_frequency;

                    // Aggregate costs based on effectiveness type
                    switch (effType) {
                        case 'cost':
                            labelStats[label].totalCostBefore += item.cost_before;
                            labelStats[label].totalCostAfter += item.cost_after;
                            break;
                        case 'main_columns':
                            labelStats[label].totalCostBefore += item.stats.before.main_columns;
                            labelStats[label].totalCostAfter += item.stats.after.main_columns;
                            break;
                        case 'constraints':
                            labelStats[label].totalCostBefore += item.stats.before.constraints;
                            labelStats[label].totalCostAfter += item.stats.after.constraints;
                            break;
                        case 'bus_interactions':
                            labelStats[label].totalCostBefore += item.stats.before.bus_interactions;
                            labelStats[label].totalCostAfter += item.stats.after.bus_interactions;
                            break;
                    }
                });
            });

            // Calculate effectiveness for each label (weighted by cost)
            const labelArray = Object.values(labelStats).map(stat => {
                // Process and sort blocks
                const processedBlocks = stat.blocks.map(block => {
                    const blockId = getBlockId(block.original_block.blocks);
                    const allStatements = block.original_block.blocks.flatMap(b => b.statements);
                    return {
                        block_id: blockId,
                        pc: block.original_block.blocks[0].start_pc,
                        traceCells: block.width_before * block.execution_frequency,
                        effectiveness: calculateEffectiveness(block, effType),
                        instructions: allStatements.length
                    };
                });

                // Sort blocks by the same criteria as the current label sort
                sortBlocksInLabel(processedBlocks);

                return {
                    label: stat.label,
                    pc: stat.pc,
                    traceCells: stat.totalTraceCells,
                    costBefore: stat.totalCostBefore,
                    costAfter: stat.totalCostAfter,
                    effectiveness: stat.totalCostBefore / stat.totalCostAfter,
                    blockCount: stat.blocks.length,
                    blocks: processedBlocks
                };
            });

            return labelArray;
        }

        function sortBlocksInLabel(blocks) {
            // Sort blocks by trace cells (descending) by default
            blocks.sort((a, b) => {
                const column = currentLabelSort.column;
                let aVal, bVal;

                switch(column) {
                    case 'traceCells':
                        aVal = a.traceCells;
                        bVal = b.traceCells;
                        break;
                    case 'effectiveness':
                        aVal = a.effectiveness;
                        bVal = b.effectiveness;
                        break;
                    case 'pc':
                        aVal = a.pc;
                        bVal = b.pc;
                        break;
                    case 'blockCount':
                        // For blockCount, sort by traceCells instead
                        aVal = a.traceCells;
                        bVal = b.traceCells;
                        break;
                    default:
                        aVal = a.traceCells;
                        bVal = b.traceCells;
                }

                if (currentLabelSort.direction === 'asc') {
                    return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
                } else {
                    return aVal > bVal ? -1 : aVal < bVal ? 1 : 0;
                }
            });
        }

        let currentLabelSort = { column: 'traceCells', direction: 'desc' };

        function createLabelsSummary() {
            const labelsSummarySection = document.getElementById('labelsSummarySection');
            const labelsTableContainer = document.getElementById('labelsTableContainer');

            // Check if there are any labels
            if (Object.keys(currentLabels).length === 0) {
                labelsSummarySection.style.display = 'none';
                return;
            }

            const labelData = aggregateLabelData();

            if (labelData.length === 0) {
                labelsSummarySection.style.display = 'none';
                return;
            }

            labelsSummarySection.style.display = 'block';

            // Set up collapsible behavior (only once)
            const labelsHeader = document.getElementById('labelsHeader');
            const labelsContent = document.getElementById('labelsContent');
            const collapseIcon = labelsHeader.querySelector('.collapse-icon');

            // Remove old listener if exists and add new one
            labelsHeader.replaceWith(labelsHeader.cloneNode(true));
            const newLabelsHeader = document.getElementById('labelsHeader');
            const newCollapseIcon = newLabelsHeader.querySelector('.collapse-icon');

            newLabelsHeader.addEventListener('click', function() {
                const content = document.getElementById('labelsContent');
                const icon = this.querySelector('.collapse-icon');

                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    icon.classList.remove('collapsed');
                } else {
                    content.style.display = 'none';
                    icon.classList.add('collapsed');
                }
            });

            // Sort data
            sortLabelData(labelData, currentLabelSort.column, currentLabelSort.direction);

            // Get metric name for column header
            const effType = effectivenessType.options[effectivenessType.selectedIndex].text;

            // Create table
            let tableHtml = `
                <table class="table labels-table">
                    <thead>
                        <tr>
                            <th style="width: 30px;"></th>
                            <th data-column="pc">PC</th>
                            <th data-column="label">Label</th>
                            <th data-column="blockCount">Blocks</th>
                            <th data-column="traceCells">Trace Cells</th>
                            <th data-column="effectiveness">Effectiveness (${effType})</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            labelData.forEach((row, idx) => {
                const labelId = `label-${idx}`;
                tableHtml += `
                    <tr class="label-row" data-pc="${row.pc}" data-label-id="${labelId}">
                        <td><span class="expand-icon">►</span></td>
                        <td>0x${row.pc.toString(16)}</td>
                        <td class="label-cell">${escapeHtml(row.label)}</td>
                        <td>${row.blockCount}</td>
                        <td>${formatCellCount(row.traceCells)}</td>
                        <td>${row.effectiveness.toFixed(2)}</td>
                    </tr>
                `;

                // Add blocks as separate rows
                row.blocks.forEach(block => {
                    tableHtml += `
                        <tr class="blocks-detail-row" id="${labelId}-detail-${block.block_id}" style="display: none;" data-block-id="${block.block_id}" data-label-id="${labelId}">
                            <td></td>
                            <td>0x${block.pc.toString(16)}</td>
                            <td>...</td>
                            <td></td>
                            <td>${formatCellCount(block.traceCells)}</td>
                            <td>${block.effectiveness.toFixed(2)}</td>
                        </tr>
                    `;
                });
            });

            tableHtml += `
                    </tbody>
                </table>
            `;

            labelsTableContainer.innerHTML = tableHtml;

            // Add sort indicators
            document.querySelectorAll('.labels-table th').forEach(th => {
                const column = th.getAttribute('data-column');
                th.classList.remove('sorted-asc', 'sorted-desc');
                if (column === currentLabelSort.column) {
                    th.classList.add(`sorted-${currentLabelSort.direction}`);
                }
            });

            // Add click handlers for sorting
            document.querySelectorAll('.labels-table th').forEach(th => {
                th.addEventListener('click', function() {
                    const column = this.getAttribute('data-column');
                    if (currentLabelSort.column === column) {
                        // Toggle direction
                        currentLabelSort.direction = currentLabelSort.direction === 'asc' ? 'desc' : 'asc';
                    } else {
                        // New column, default to descending
                        currentLabelSort.column = column;
                        currentLabelSort.direction = 'desc';
                    }
                    createLabelsSummary();
                });
            });

            // Add click handlers for label rows (expand/collapse)
            document.querySelectorAll('.label-row').forEach(tr => {
                const expandIcon = tr.querySelector('.expand-icon');
                const labelId = tr.getAttribute('data-label-id');

                // Click on expand icon or first cell to expand
                const expandCell = tr.querySelector('td:first-child');
                expandCell.addEventListener('click', function(e) {
                    e.stopPropagation();

                    // Find all detail rows for this label
                    const detailRows = document.querySelectorAll(`[data-label-id="${labelId}"].blocks-detail-row`);
                    const isExpanded = expandIcon.classList.contains('expanded');

                    if (isExpanded) {
                        detailRows.forEach(row => row.style.display = 'none');
                        expandIcon.classList.remove('expanded');
                    } else {
                        detailRows.forEach(row => row.style.display = 'table-row');
                        expandIcon.classList.add('expanded');
                    }
                });

                // Click on rest of row to select first block of this label
                tr.addEventListener('click', function(e) {
                    if (e.target.closest('td:first-child')) return; // Ignore if clicking expand cell
                    const pc = parseInt(this.getAttribute('data-pc'));
                    const data = processData();
                    // Find block where any sub-block starts at this PC
                    const block = data.find(d => d.blocks && d.blocks.some(b => b.start_pc === pc));
                    if (block) {
                        selectBlock(block);
                    }
                });
            });

            // Add click handlers for individual block rows
            document.querySelectorAll('.blocks-detail-row').forEach(tr => {
                tr.addEventListener('click', function() {
                    const blockId = this.getAttribute('data-block-id');
                    const data = processData();
                    const block = data.find(d => d.block_id === blockId);
                    if (block) {
                        selectBlock(block);
                    }
                });
            });
        }

        function sortLabelData(data, column, direction) {
            data.sort((a, b) => {
                let aVal = a[column];
                let bVal = b[column];

                // Special handling for label (case-insensitive string sort)
                if (column === 'label') {
                    aVal = aVal.toLowerCase();
                    bVal = bVal.toLowerCase();
                }

                if (direction === 'asc') {
                    return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
                } else {
                    return aVal > bVal ? -1 : aVal < bVal ? 1 : 0;
                }
            });
        }

        function highlightElements(blockId, isHover = true) {
            // Highlight corresponding bar
            d3.selectAll('.bar')
                .classed('bar-highlight', d => d.block_id === blockId);
        }

        function clearHighlights() {
            d3.selectAll('.bar').classed('bar-highlight', false);
        }
        
        function selectBlock(blockData) {
            // Clear previous selection
            d3.selectAll('.bar').classed('bar-selected', false);

            // Set new selection
            selectedBlock = blockData;

            // Update URL
            const newUrl = new URL(window.location);
            if (blockData && !blockData.is_other) {
                // Highlight selected bar
                d3.selectAll('.bar')
                    .classed('bar-selected', d => d.block_id === blockData.block_id);

                // Update URL with block parameter (use block_id which is the sequence of PCs)
                newUrl.searchParams.set('block', blockData.block_id);

                // Update the PC search input field with first PC
                pcSearch.value = '0x' + blockData.start_pc.toString(16);
            } else {
                // Clear block parameter if deselecting or selecting "Other"
                newUrl.searchParams.delete('block');

                // Clear the PC search input field
                pcSearch.value = '';
            }
            window.history.replaceState({}, document.title, newUrl);

            // Update code panel selection
            updateCodePanelSelection(blockData);
        }

        function showAllCode() {
            const codePanel = document.getElementById('codePanel');

            // Get all blocks sorted by first start_pc
            const allBlocks = processData().sort((a, b) => a.start_pc - b.start_pc);

            let codeHtml = '';
            allBlocks.forEach((block, index) => {
                if (block.is_other) return; // Skip "Other" grouped blocks

                // Check if this block's first start_pc has labels
                const pcKey = block.start_pc.toString();
                let labelData = '';
                if (currentLabels[pcKey] && currentLabels[pcKey].length > 0) {
                    const labels = currentLabels[pcKey];
                    const labelsHtml = labels.map(label =>
                        `<div class="label-name">${escapeHtml(label)}</div>`
                    ).join('');
                    // Store labels as JSON array to preserve them correctly
                    labelData = JSON.stringify(labels);
                    codeHtml += `
                        <div class="label-line" data-pc="${block.start_pc}" data-block-id="${block.block_id}" data-labels='${labelData}'>
                            ${labelsHtml}
                        </div>
                    `;
                }

                const blockElementId = `block-${block.block_id}`;
                const pcsDisplay = block.blocks.map(b => '0x' + b.start_pc.toString(16)).join(' → ');
                const headerText = `PCs: ${pcsDisplay} | Cells: ${formatCellCount(block.software_version_cells)} | Effectiveness: ${block.effectiveness.toFixed(2)} | Instructions: ${block.instructions}`;

                // Build the code lines showing each sub-block
                let linesHtml = '';
                block.blocks.forEach((subBlock, subIdx) => {
                    // Add sub-block header if there are multiple sub-blocks
                    if (block.blocks.length > 1) {
                        linesHtml += `<div style="color: #666; font-size: 11px; margin-top: ${subIdx > 0 ? '10px' : '5px'}; margin-bottom: 2px; border-top: ${subIdx > 0 ? '1px dashed #ddd' : 'none'}; padding-top: ${subIdx > 0 ? '5px' : '0'};">Sub-block ${subIdx + 1}: PC 0x${subBlock.start_pc.toString(16)}</div>`;
                    }
                    subBlock.statements.forEach((stmt, idx) => {
                        linesHtml += `<div class="code-line" data-block-id="${block.block_id}" data-sub-block="${subIdx}" data-line="${idx}">${escapeHtml(stmt)}</div>`;
                    });
                });

                codeHtml += `
                    <div class="code-block" id="${blockElementId}" data-block-id="${block.block_id}" data-labels='${labelData}'>
                        <div class="code-block-header">${headerText}</div>
                        ${linesHtml}
                    </div>
                `;
            });

            codePanel.innerHTML = codeHtml;

            // Add click handlers to code lines
            document.querySelectorAll('.code-line').forEach(line => {
                line.addEventListener('click', function() {
                    const blockId = this.getAttribute('data-block-id');
                    const blockData = allBlocks.find(b => b.block_id === blockId);
                    if (blockData) {
                        selectBlock(blockData);
                    }
                });
            });

            // Set up scroll listener to update sticky header
            updateStickyLabel();
            codePanel.removeEventListener('scroll', updateStickyLabel);
            codePanel.addEventListener('scroll', updateStickyLabel);

            // Set up click handler for sticky header
            const stickyHeader = document.getElementById('stickyLabelHeader');
            if (stickyHeader) {
                stickyHeader.removeEventListener('click', handleStickyLabelClick);
                stickyHeader.addEventListener('click', handleStickyLabelClick);
            }
        }

        function handleStickyLabelClick() {
            const stickyHeader = document.getElementById('stickyLabelHeader');
            const blockId = stickyHeader.getAttribute('data-block-id');

            if (blockId) {
                const data = processData();
                const block = data.find(d => d.block_id === blockId);

                if (block) {
                    selectBlock(block);
                }
            }
        }

        function updateStickyLabel() {
            const codePanel = document.getElementById('codePanel');
            const stickyHeader = document.getElementById('stickyLabelHeader');

            if (!codePanel || !stickyHeader) return;

            // Find the first visible block or label
            const scrollTop = codePanel.scrollTop;
            const panelTop = codePanel.getBoundingClientRect().top;

            // Get all blocks and labels
            const elements = codePanel.querySelectorAll('.label-line, .code-block');
            let currentLabelsList = null;
            let currentBlockId = null;

            for (let i = 0; i < elements.length; i++) {
                const element = elements[i];
                const elementTop = element.offsetTop;

                // If this element is past our scroll position, use the previous label
                if (elementTop > scrollTop) {
                    break;
                }

                // Check if this element has labels
                const labelsAttr = element.getAttribute('data-labels');
                if (labelsAttr && labelsAttr !== '""' && labelsAttr !== '') {
                    try {
                        currentLabelsList = JSON.parse(labelsAttr);
                        currentBlockId = element.getAttribute('data-block-id');
                    } catch (e) {
                        // Ignore parse errors
                    }
                }
            }

            // Update sticky header
            if (currentLabelsList && currentLabelsList.length > 0 && currentBlockId) {
                const labelHtml = currentLabelsList.map(label =>
                    `<div class="label-name">${escapeHtml(label)}</div>`
                ).join('');
                stickyHeader.innerHTML = labelHtml;
                stickyHeader.setAttribute('data-block-id', currentBlockId);
                stickyHeader.classList.add('active');
            } else {
                stickyHeader.classList.remove('active');
                stickyHeader.removeAttribute('data-block-id');
            }
        }

        function updateCodePanelSelection(blockData) {
            const codeInfo = document.getElementById('codeBlockInfo');

            // Remove all previous selections
            document.querySelectorAll('.code-block').forEach(block => {
                block.classList.remove('selected');
            });
            document.querySelectorAll('.code-line').forEach(line => {
                line.classList.remove('highlighted');
            });

            if (!blockData) {
                codeInfo.innerHTML = '<span class="text-muted">Click on a bar or code line to select a block</span>';
                return;
            }

            if (blockData.is_other) {
                codeInfo.innerHTML = `
                    <strong>Other blocks (${blockData.count} APCs grouped)</strong><br/>
                    <span>Cells (software version): ${formatCellCount(blockData.software_version_cells)}</span> •
                    <span>Execution frequency: ${formatCellCount(blockData.execution_frequency)}</span><br/>
                    <span>Effectiveness: ${blockData.effectiveness.toFixed(2)}</span><br/>
                    <span>APC size (total): ${blockData.stats_after.main_columns || 0} columns, ${blockData.stats_after.bus_interactions || 0} bus interactions, ${blockData.stats_after.constraints || 0} constraints</span>
                `;
                return;
            }

            const pcsDisplay = blockData.blocks.map(b => '0x' + b.start_pc.toString(16)).join(' → ');
            codeInfo.innerHTML = `
                <strong>Block PCs: ${pcsDisplay}</strong><br/>
                <span>Cells (software version): ${formatCellCount(blockData.software_version_cells)}</span> •
                <span>Execution frequency: ${formatCellCount(blockData.execution_frequency)}</span> •
                <span>Instructions: ${blockData.instructions}</span> •
                <span>Sub-blocks: ${blockData.blocks.length}</span><br/>
                <span>Effectiveness: ${blockData.effectiveness.toFixed(2)}</span><br/>
                <span>APC size: ${blockData.stats_after.main_columns} columns, ${blockData.stats_after.bus_interactions} bus interactions, ${blockData.stats_after.constraints} constraints</span>
            `;

            // Highlight the selected block
            const blockElement = document.getElementById(`block-${blockData.block_id}`);
            if (blockElement) {
                blockElement.classList.add('selected');

                // Highlight all lines in this block
                blockElement.querySelectorAll('.code-line').forEach(line => {
                    line.classList.add('highlighted');
                });

                // Scroll within the code panel only, not the whole page
                const codePanel = document.getElementById('codePanel');
                const blockTop = blockElement.offsetTop;
                codePanel.scrollTo({ top: blockTop, behavior: 'smooth' });
            }
        }

        function clearCode() {
            // Only clear if there's no selected block
            if (!selectedBlock) {
                document.getElementById('codeBlockInfo').innerHTML = '<span class="text-muted">Click on a bar or code line to select a block</span>';
                showAllCode();
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function createChart(data, totalCells, meanEffectiveness) {
            // Clear existing chart
            d3.select('#chart').selectAll('*').remove();

            // Set dimensions and margins
            const margin = { top: 40, right: 120, bottom: 60, left: 80 };
            const width = 1200 - margin.left - margin.right;
            const height = 225 - margin.top - margin.bottom;

            // Group small blocks (< 0.1% threshold)
            const threshold = totalCells * 0.001;
            const largeBlocks = data.filter(d => d.software_version_cells >= threshold);
            const smallBlocks = data.filter(d => d.software_version_cells < threshold);

            let plotData = [...largeBlocks];

            if (smallBlocks.length > 0) {
                const otherCells = smallBlocks.reduce((sum, d) => sum + d.software_version_cells, 0);
                const otherEffectiveness = smallBlocks.reduce((sum, d) => sum + d.effectiveness * d.software_version_cells, 0) / otherCells;
                const otherExecFreq = smallBlocks.reduce((sum, d) => sum + d.execution_frequency, 0);
                const otherStatsAfter = smallBlocks.reduce((acc, d) => {
                    if (d.stats_after) {
                        acc.main_columns = (acc.main_columns || 0) + d.stats_after.main_columns;
                        acc.bus_interactions = (acc.bus_interactions || 0) + d.stats_after.bus_interactions;
                        acc.constraints = (acc.constraints || 0) + d.stats_after.constraints;
                    }
                    return acc;
                }, {});
                plotData.push({
                    effectiveness: otherEffectiveness,
                    software_version_cells: otherCells,
                    execution_frequency: otherExecFreq,
                    instructions: -1,
                    is_other: true,
                    count: smallBlocks.length,
                    statements: [],  // No individual statements for grouped blocks
                    stats_after: otherStatsAfter
                });
            }

            // Calculate positions
            let xPos = 0;
            plotData.forEach(d => {
                d.x = xPos;
                d.width = d.software_version_cells;
                xPos += d.width;
            });

            // Create SVG
            const svg = d3.select('#chart')
                .append('svg')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom)
                .on('click', function(event) {
                    // If clicking on the background (not a bar), deselect
                    if (event.target.tagName === 'svg') {
                        selectBlock(null);
                    }
                })
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Add background rect to capture clicks
            svg.append('rect')
                .attr('width', width)
                .attr('height', height)
                .style('fill', 'none')
                .style('pointer-events', 'all')
                .on('click', function(event) {
                    event.stopPropagation();
                    selectBlock(null);
                });

            // Create scales
            const xScale = d3.scaleLinear()
                .domain([0, totalCells])
                .range([0, width]);

            // Calculate 99th percentile effectiveness by trace cells
            // Sort by effectiveness ascending
            const sortedByEffectiveness = [...plotData].sort((a, b) => a.effectiveness - b.effectiveness);

            // Find the effectiveness value at 99th percentile weighted by trace cells
            let cumulativeCells = 0;
            const p99Threshold = totalCells * 0.99;
            let maxEffectivenessP99 = 0;

            for (const d of sortedByEffectiveness) {
                cumulativeCells += d.software_version_cells;
                maxEffectivenessP99 = d.effectiveness;
                if (cumulativeCells >= p99Threshold) {
                    break;
                }
            }

            // Use 99th percentile for y-axis scaling
            const yScale = d3.scaleLinear()
                .domain([0, maxEffectivenessP99 * 1.1])
                .range([height, 0]);

            // Color scale for instructions (log scale)
            const validInstructions = plotData.filter(d => !d.is_other).map(d => d.instructions);
            const colorScale = d3.scaleSequentialLog()
                .domain([d3.min(validInstructions), d3.max(validInstructions)])
                .interpolator(d3.interpolateRdYlGn);

            // Add grid
            svg.append('g')
                .attr('class', 'grid')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(xScale)
                    .tickSize(-height)
                    .tickFormat(''));

            svg.append('g')
                .attr('class', 'grid')
                .call(d3.axisLeft(yScale)
                    .tickSize(-width)
                    .tickFormat(''));

            // Create tooltip
            const tooltip = d3.select('body').append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);

            // Add bars
            svg.selectAll('.bar')
                .data(plotData)
                .enter().append('rect')
                .attr('class', 'bar')
                .attr('x', d => xScale(d.x))
                .attr('y', d => Math.max(0, yScale(d.effectiveness)))
                .attr('width', d => xScale(d.width) - xScale(0))
                .attr('height', d => height - Math.max(0, yScale(d.effectiveness)))
                .style('fill', d => d.is_other ? 'lightgray' : colorScale(d.instructions))
                .on('mouseover', function (event, d) {
                    // Show tooltip
                    tooltip.transition()
                        .duration(200)
                        .style('opacity', .9);

                    let content = '';
                    if (d.is_other) {
                        content = `<strong>Other (${d.count} APCs)</strong><br/>
                                  Cells (software version): ${formatCellCount(d.software_version_cells)}<br/>
                                  Execution frequency: ${formatCellCount(d.execution_frequency)}<br/>
                                  Effectiveness: ${d.effectiveness.toFixed(2)}<br/>
                                  APC columns (total): ${d.stats_after.main_columns || 'N/A'}<br/>
                                  APC bus interactions (total): ${d.stats_after.bus_interactions || 'N/A'}<br/>
                                  APC constraints (total): ${d.stats_after.constraints || 'N/A'}`;
                    } else {
                        const pcsDisplay = d.blocks.map(b => '0x' + b.start_pc.toString(16)).join(' → ');
                        content = `<strong>PCs: ${pcsDisplay}</strong><br/>
                                  Cells (software version): ${formatCellCount(d.software_version_cells)}<br/>
                                  Execution frequency: ${formatCellCount(d.execution_frequency)}<br/>
                                  Effectiveness: ${d.effectiveness.toFixed(2)}<br/>
                                  Instructions: ${d.instructions}<br/>
                                  Sub-blocks: ${d.blocks.length}<br/>
                                  APC columns: ${d.stats_after.main_columns}<br/>
                                  APC bus interactions: ${d.stats_after.bus_interactions}<br/>
                                  APC constraints: ${d.stats_after.constraints}`;
                    }

                    tooltip.html(content)
                        .style('left', (event.pageX - 50) + 'px')
                        .style('top', (event.pageY + 20) + 'px');

                    // Highlight elements (but don't change code on hover if something is selected)
                    if (!d.is_other) {
                        highlightElements(d.block_id, true);
                    }
                })
                .on('mouseout', function (d) {
                    // Hide tooltip
                    tooltip.transition()
                        .duration(500)
                        .style('opacity', 0);

                    // Clear highlights
                    clearHighlights();
                })
                .on('click', function(event, d) {
                    event.stopPropagation();
                    // Select this block on click
                    selectBlock(d);
                });
            
            // Note: Selection is handled in the selectBlock function after chart is created

            // Add "Other" label for wide enough other blocks
            plotData.filter(d => d.is_other && d.width > totalCells * 0.02).forEach(d => {
                svg.append('text')
                    .attr('x', xScale(d.x + d.width / 2))
                    .attr('y', yScale(d.effectiveness / 2))
                    .attr('text-anchor', 'middle')
                    .attr('font-size', '10px')
                    .attr('font-weight', 'bold')
                    .text(`Other (${d.count} APCs)`);
            });

            // Add mean line
            svg.append('line')
                .attr('class', 'mean-line')
                .attr('x1', 0)
                .attr('x2', width)
                .attr('y1', yScale(meanEffectiveness))
                .attr('y2', yScale(meanEffectiveness));

            // Add axes
            svg.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(xScale)
                    .tickFormat(d => formatCellCount(d)));

            svg.append('g')
                .call(d3.axisLeft(yScale));

            // Add labels
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', 0 - margin.left)
                .attr('x', 0 - (height / 2))
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .text('Effectiveness');

            svg.append('text')
                .attr('transform', `translate(${width / 2}, ${height + margin.bottom})`)
                .style('text-anchor', 'middle')
                .text('Cumulative instruction trace cells (software version)');

            // Add title
            const effType = effectivenessType.options[effectivenessType.selectedIndex].text;
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', 0 - margin.top / 2)
                .attr('text-anchor', 'middle')
                .style('font-size', '16px')
                .style('font-weight', 'bold')
                .text(`Effectiveness by Basic Block (reduction in ${effType})`);

            // Add mean text box
            svg.append('rect')
                .attr('x', 5)
                .attr('y', 5)
                .attr('width', 80)
                .attr('height', 25)
                .style('fill', 'wheat')
                .style('opacity', 0.8)
                .style('stroke', 'gray')
                .style('stroke-width', 1)
                .style('rx', 3);

            svg.append('text')
                .attr('x', 45)
                .attr('y', 22)
                .attr('text-anchor', 'middle')
                .style('font-size', '12px')
                .text(`Mean: ${meanEffectiveness.toFixed(2)}`);

            // Add color legend
            if (validInstructions.length > 0) {
                const legendWidth = 20;
                const legendHeight = 200;

                const legendScale = d3.scaleLinear()
                    .domain([Math.log10(d3.min(validInstructions)), Math.log10(d3.max(validInstructions))])
                    .range([legendHeight, 0]);

                const legendAxis = d3.axisRight(legendScale)
                    .ticks(5)
                    .tickFormat(d => Math.pow(10, d).toFixed(0));

                const legend = svg.append('g')
                    .attr('transform', `translate(${width + 40}, ${height / 2 - legendHeight / 2})`);

                // Create gradient
                const gradientId = 'instruction-gradient';
                const gradient = svg.append('defs')
                    .append('linearGradient')
                    .attr('id', gradientId)
                    .attr('x1', '0%')
                    .attr('y1', '100%')
                    .attr('x2', '0%')
                    .attr('y2', '0%');

                const steps = 20;
                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const value = d3.min(validInstructions) * Math.pow(d3.max(validInstructions) / d3.min(validInstructions), t);
                    gradient.append('stop')
                        .attr('offset', `${t * 100}%`)
                        .style('stop-color', colorScale(value));
                }

                legend.append('rect')
                    .attr('width', legendWidth)
                    .attr('height', legendHeight)
                    .style('fill', `url(#${gradientId})`);

                legend.append('g')
                    .attr('transform', `translate(${legendWidth}, 0)`)
                    .call(legendAxis);

                legend.append('text')
                    .attr('transform', `rotate(90)`)
                    .attr('y', -legendWidth - 30)
                    .attr('x', legendHeight / 2)
                    .style('text-anchor', 'middle')
                    .style('font-size', '12px')
                    .text('Instructions (log)');
            }
        }
    </script>
</body>

</html>